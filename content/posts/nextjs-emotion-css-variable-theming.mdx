---
title: 'Exploring Next.js, Emotion & CSS Variable Theming'
date: '2021-20-03'
excerpt: 'A path to betters DX by combining elements from other great tools.'
author: 'Tom Hendra'
image: '/images/gadgets.jpg'
caption: 'An image of gadgets.'
tags: ['Next.js', 'Emotion', 'CSS', 'Theme UI']
---

The first thing I ever built with React was my personal site, and I got very carried away. Essentially I built a reusbale component library for a one-off project, powered by Sanity.io CMS configured with a custom dashboard which displayed Google Analytics data. From what I see from the community, most people new to the industry learn by building small projects that solve differing problems of increasing complexity. I on the other hand chose the path of the "Featurist"; iterating over several versions of the same project, adding features, striving for cleaner code and a better developer experience (DX) even though I was the only developer consuming the components!

It was fun to build and I learned a tonne, but it was like using a jet turbine to power a lawnmower. The subsequent version needed to be approached with a gentler hand. Next.js is what all the cool kids are using but is still overkill. I mean, who needs an all-powerful fullstack React framework for a simple blog? But eager to see what all the fuss was about and stick to with beloved React, the choice was already made.

## Styling

I love great DX as much as the next dev, which is why I ended up going too far with my Gatsby site's components. The entire four pages of the site were written in squeaky clean markup because I spent weeks tweaking a component API to avoid using Emotion's css prop in my page markup. Instead I implelemented components to accept style props to create options, like a component library might do, ladeling on the complexity unnecessarily.

But I was not building a design system (intentionally) so decided to explore what tools were available to spare me from (a) spending so much time writing code for components and (b) the horror of untidy page markup, with css prop styles all over the place to tweak spacing here and there while chasing pixel-perfection. After a fair amount of reseacrh, the standout contenders were [Theme UI](https://theme-ui.com/) and [Tailwind CSS](https://tailwindcss.com/).

## Theme UI

I really like the principle of a standardized theme specification. Theme UI isn't just some venture into the unknown clutching a fancy idea, it has been developed with careful consideration derived from lessons learned during the evolution of several other libraries that came before it, which gives Theme UI credibility.

While I enjoyed the DX, I didn't enjoy fighting with alpha versions and configs for compatability with the latest version of Next.js. I also struggled to find answers to questions about what is a surprisingly unpopular styling solution. It also felt like too much abstraction from plain CSS in some areas such as media queries, and since I want to grow my CSS skills it is important to not remove myself too much from actually writing it.

## Tailwind CSS

Tailwind has gained a lot of traction and for good reasaon; the underlying design system is sublime. Having the glorious Refactoring UI book already in my toolkit, I have tremendous respect for Adam Wathan & Steve Schoger's work. Refactoring UI opens portals that connect the developer and design realms, and the result is like using Figma with cheat codes!

But seeing a troupe of classnames lined up makes me feel uneasy. Given the glowing feedback Tailwind receives, I am sure the unease subsides with acclimitization, and I fully intend to test that theory at some point. But for my personal site I want easy to read and maintainable code; a testing ground for all the shiny new things must be free from chaos for quick iteration. There was also the requirement to learn the Tailwind API rather than build upon the CSS skills that I want to develop.

## Eureka

Then came a lightbulb moment: Maybe new tooling wasn't the right solution. I liked the structured theming of Theme UI, and the well considered design system of Tailwind, but didn't want to use a tool that abstracted away from vanilla CSS too much. I was already on good terms with Emotion after the Gatsby site I put so much time into, so why not take some features from Theme UI and Tailwind and implement them myself with Emotion? That way I can stay closer to vanilla CSS and as a bonus get to explore some of how the other tools work under the hood.

## But What About Reducing Complexity?

In the outset I wanted to avoid two things that bothered me while implementing my personal site the first time around:

1.  Spending too much time implementing components
2.  Writing untidy code in implementing pages

The search for technical solutions gave rise to an unexpected realization. While tools like Theme UI and Tailwind CSS are great for speedy development and provde a fantastic API, in the interest of growing my CSS skills I found that I wasn't comfortable with the level of abstraction that those tools provide.

My problems could be better solved with a change in mindset: I am building a personal site and blog with a handful of pages. It isn't justifiable to spend time on creating a clean component API. For the few basic pages I need, use of the css prop for tweaks here and there in the markup isn't really much of a problem at all. So with this new ethos it was time to give more consideration to the "new" approach.

## CSS Variable Theming

React superhero, Kent C. Dodds, enlightened me to the performance benefits of CSS variables over React context with his blog post [Use CSS Variables instead of React Context](https://epicreact.dev/css-variables/). Performance **always** matters, and with [95% browser coverage](https://caniuse.com/css-variables) it was an easy sell. In terms of how to put together colour swatches as part of a design system, inspiration came from Tailwind CSS, and implmentation from Elad Shechter with his article on [Why CSS HSL Colors are Better!](https://elad.medium.com/why-css-hsl-colors-are-better-83b1e0b6eead) The plan was in place.

## The Configuration

So how do we stitch all of this together for performant, well-organized theming coupled with the great DX of Emotion? We create a hybrid by following these steps:

1. Setup Emotion to work with the latest version of Next.js.
2. Take some design system elements from Tailwind and create a CSS Variable configuration.
3. Create a theme object based on the theme specification from Theme UI which consumes the CSS Variables.
4. Create a toggle component to switch between themes.

## Configuring Emotion with Next.js

Emotion 11 installation is as easy as `npm i @emotion/react @emotion/styled`. To avoid having to use a pragma atop every file that relies on the Emotion `css` prop, we also want to `npm i @emotion/babel-plugin`. For the plugin to work, and to use [the new JSX transform](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) in React 17 which ships with the latest verion of Next.js, we need to define a custom Babel config as follows in a `.babelrc` file in the root directory.

```shell
{
  "presets": [
    [
      "next/babel",
      {
        "preset-react": {
          "runtime": "automatic",
          "importSource": "@emotion/react"
        }
      }
    ]
  ],
  "plugins": ["@emotion/babel-plugin"]
}
```

## Defining CSS Variables for the Theme

We define our colour scales Tailwind-style using CSS variables.

```css
/* styles/colors.css */
:root {
  --gray: 343, 6%;
  --gray-50: var(--gray), 95%;
  --gray-100: var(--gray), 90%;
  --gray-200: var(--gray), 80%;
  --gray-300: var(--gray), 70%;
  --gray-400: var(--gray), 60%;
  --gray-500: var(--gray), 50%;
  --gray-600: var(--gray), 40%;
  --gray-700: var(--gray), 30%;
  --gray-800: var(--gray), 20%;
  --gray-900: var(--gray), 10%;

  /* ...add other color swatches as desired */
}

body[data-theme='light'] {
  --colors-text: hsla(var(--gray-800), 100%);
  --colors-background: hsla(var(--yellow-50), 100%);
  --colors-primary: hsla(var(--orange-500), 100%);
  --colors-secondary: hsla(var(--orange-300), 100%);
  --colors-accent: hsla(var(--olive-600), 100%);
  --colors-highlight: hsla(var(--teal-200), 100%);
  --colors-muted: hsla(var(--yellow-200), 100%);
}

body[data-theme='dark'] {
  --colors-text: hsla(var(--yellow-50), 100%);
  --colors-background: hsla(var(--gray-800), 100%);
  --colors-primary: hsla(var(--orange-500), 100%);
  --colors-secondary: hsla(var(--orange-300), 100%);
  --colors-accent: hsla(var(--olive-600), 100%);
  --colors-highlight: hsla(var(--teal-200), 100%);
  --colors-muted: hsla(var(--yellow-200), 100%);
}
```

## Creating & Using a Theme with Emotion

Then we follow [Theme UI's theme specification](https://dev.theme-ui.com/theme-spec/) to build a thoughtfully structured theme, using our CSS variables for the `colors` object.

```ts
const baseColors = {
  transparent: 'transparent',
  black: '#000',
  white: '#fff',
  gray: [
    'var(--gray-50)',
    'var(--gray-100)',
    'var(--gray-200)',
    'var(--gray-300)',
    'var(--gray-400)',
    'var(--gray-500)',
    'var(--gray-600)',
    'var(--gray-700)',
    'var(--gray-800)',
    'var(--gray-900)',
  ],
  // other color swatches from colors.css
};

const defaultColors = {
  text: 'var(--colors-text)',
  background: 'var(--colors-background)',
  primary: 'var(--colors-primary)',
  secondary: 'var(--colors-secondary)',
  accent: 'var(--colors-accent)',
  highlight: 'var(--colors-highlight)',
  muted: 'var(--colors-muted)',
};

export const colors = {
  ...baseColors,
  ...defaultColors,
};
```

Next we use Emotion's `<Global/>` component to apply the theme colors.

```tsx
// _app.tsx
import type { AppProps } from 'next/app';
import { Global } from '@emotion/react';
import theme from 'theme';
import 'styles/colors.css';

function App({ Component, pageProps }: AppProps) {
  return (
    <>
      <Global
        styles={{
          body: {
            background: theme.colors.background,
            color: theme.colors.text,
          },

          a: {
            color: theme.colors.primary,
          },
        }}
      />
      <Component {...pageProps} />
    </>
  );
}

export default App;
```

## Building a Theme Toggle Component

And lastly we create a theme toggle to switch between themes using CSS [data attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes).

```tsx
// ModeToggle.tsx
import * as React from 'react';
import { FiSun, FiMoon } from 'react-icons/fi';
import { StyledButton } from './styled';
import { useLocalStorageState } from 'hooks';

export function ModeToggle() {
  const [theme, setTheme] = React.useState('light');
  const nextTheme = theme === 'light' ? 'dark' : 'light';

  React.useEffect(() => {
    document.body.dataset.theme = theme;
  }, [theme]);

  return (
    <StyledButton
      aria-label="Toggle colour mode"
      onClick={() => setTheme(nextTheme)}
    >
      {nextTheme === 'light' ? <FiMoon /> : <FiSun />}
    </StyledButton>
  );
}
```

## Just One More Thing...

But there is one more matter to consider. Next.js re-renders on route changes and therefore our theme state will be lost when we navigate to a different page. We need to persist state, for which we will use `localStorage`.

## Persisting Between Route Changes

One of the many elegant patterns I learned from Kent C Dodd's [Epic React](https://epicreact.dev/) course is to create a generic custom hook for storing state in `localStorage`. To avoid an error being thrown, we also need to ensure not to try and access `window` on the server where it will be `undefined` as per the [Next.js docs](https://nextjs.org/docs/migrating/from-create-react-app#safely-accessing-web-apis).

```tsx
// use-local-storage-state.tsx
import * as React from 'react';

export function useLocalStorageState(
  key: string,
  defaultValue: string | (() => void),
  { serialize = JSON.stringify, deserialize = JSON.parse } = {},
) {
  const [state, setState] = React.useState(() => {
    // do not try to run this on the server!
    if (typeof window === 'undefined') return;
    const valueInLocalStorage = window.localStorage.getItem(key);

    if (valueInLocalStorage) {
      // the try/catch is here in case the localStorage value was set before we had the serialization in place
      try {
        return deserialize(valueInLocalStorage);
      } catch (error) {
        window.localStorage.removeItem(key);
      }
    }
    return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
  });

  const prevKeyRef = React.useRef(key);

  React.useEffect(() => {
    const prevKey = prevKeyRef.current;
    if (prevKey !== key) {
      window.localStorage.removeItem(prevKey);
    }
    prevKeyRef.current = key;
    window.localStorage.setItem(key, serialize(state));
  }, [key, state, serialize]);

  return [state, setState];
}
```

Now we can replace the call to `React.useState()` with `useLocalStorageState()` in our `ModeToggle` component.

```tsx
import { FiSun, FiMoon } from 'react-icons/fi';
import { StyledButton } from './styled';
import { useLocalStorageState } from 'hooks';

export function ModeToggle() {
  const [theme, setTheme] = useLocalStorageState('theme', 'light');
  const nextTheme = theme === 'light' ? 'dark' : 'light';

  React.useEffect(() => {
    document.body.dataset.theme = theme;
  }, [theme]);

  return (
    <StyledButton
      aria-label="Toggle colour mode"
      onClick={() => setTheme(nextTheme)}
    >
      {nextTheme === 'light' ? <FiMoon /> : <FiSun />}
    </StyledButton>
  );
}
```

## Summary

To recap, we have created a Next.js configuration with great DX featuring:

- Emotion for [all of the benefits](https://mxstbr.com/thoughts/css-in-js/) that CSS-in-JS brings configured to work with the latest version of Next.js.
- Perforamant theming through the use of CSS Custom Properties (variables).
- An organized theme structure based on the theme specification used by Theme UI.
- An elegant reusable hook for storing anything we wish in the browser's local storage.

The big takeaway I have learned from all of this is to use a suitable approach for the task at hand, and not create complexity where it isn't justifiable. Sometimes we can get carried away with creating solutions for problems that don't really exist, which only becomes apparent when we step away from the code and reassess our observation of the situation with a wider perspective.
