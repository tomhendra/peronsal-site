---
title: 'Exploring Next.js, Emotion & CSS Variable Theming'
date: '2021-20-03'
excerpt: 'A path to great DX by taking elements from other great tools.'
author: 'Tom Hendra'
image: '/images/gadgets.jpg'
caption: 'An image of gadgets.'
tags: ['Next.js', 'Emotion', 'CSS', 'Theme UI']
---

I recently decided to revamp my blog for the third time, and like many others in the community decided to follow the trend in moving from Gatsby to Next.js. My old blog had served me well but it was too complex for my needs. It was the first thing I ever built with React and I got carried away, essentially building a reusbale component library for a one-off website hooked up to a Sanity.io CMS. It was fun to build and I learned a tonne, but it was like using a jet turbine to power my lawnmower. I needed to approach the subsequent iteration with a gentler hand.

Next.js is still overkill, I mean who needs an all-powerful fullstack React framework for a simple blog? But I am eager to learn Next.js as that's what all the cool kids are doing, so the choice was already made.

## Styling

I love a great developer experience (DX) as much as the next person, which is why I ended up going too far with my Gatsby site's components. The entire four pages of the site were written in squeaky clean markup because I spent a lot of time on a component API to avoid using Emotion's css prop in my pages. Instead I implelemented components to accept style props, like a component library might do, ladeling on the complexity.

But I am not building a design system (yet) so I decided to explore what tools were available to spare me from (a) spending too much time writing component code and (b) the horror of writing untidy code for my pages, with css prop styles all over the place to tweak spacing here and there while chasing pixel-perfection. The standout options were [Theme UI](https://theme-ui.com/) and [Tailwind CSS](https://tailwindcss.com/).

## Theme UI

I really like the principle of a standardized theme specification. Theme UI isn't just some venture into the unknown clutching a fancy idea, it has been developed with careful consideration derived from lessons learned during the evolution of several other libraries that came before it, which gives Theme UI credibility.

While I enjoyed the DX, I didn't enjoy fighting with alpha versions and configs for compatability with the latest version of Next.js. I also struggled to find answers to questions about what is a surprisingly unpopular styling solution. It was also too much abstraction from plain CSS in some areas such as media queries, and since I want to grow my CSS skills it is important to not remove myself too much from actually writing it.

## Tailwind CSS

Tailwind has gained a lot of traction and for good reasaon; the underlying design system is sublime. Having the glorious Refactoring UI already in my toolkit I have tremendous respect for Adam Wathan & Steve Schoger's work. Refactoring UI opens portals from the developer realm to the design one, and the result is like using Figma with cheat codes!

But seeing a troupe of classnames lined up makes me feel uneasy. Given the glowing feedback Tailwind receives, I am sure the unease subsides with acclimitization, and I fully intend to test that theory at some point. But for my personal site I need easy to read and maintainable code; a testing ground for all the shiny new things must be free from chaos for quick iteration. There was also the requirement to use the Tailwind API rather than build upon the CSS skills that I want to develop.

## Eureka

Then came the lightbulb moment: Maybe a new tool wasn't the right solution. I liked the structured theming of Theme UI, and the well considered design system of Tailwind, but didn't want to use a tool that abstracted away from plain CSS too much. I was already on good terms with Emotion after the Gatsby site I spent so much time iterating upon and learning from, so why not take some features from Theme UI and Tailwind and implement them myself with Emotion? That way I can stay closer to vanilla CSS and as a bonus get to explore some of how the other tools work.

## But What About Reducing Complexity?

In the outset I wanted to avoid two things that bothered me while implementing the previous iteration of my personal site:

1.  Spending too much time implementing components
2.  Writing untidy code implementing pages

The search for technical solutions gave rise to an unexpected realization. While tools like Theme UI and Tailwind CSS are great for speedy development and provde a fantastic API, in the interest of growing my CSS skills I found that I wasn't confortable with the level of abstraction that these tools provide.

My problems would be better soloved with a change in mindset. In this case, I am building a personal site and blog with a handful of pages. It isn't justifiable to spend time on creating a clean component API. For the few basic pages I need, use of the css prop for tweaks here and there in the markup isn't really much of a problem at all.

## CSS Variable Theming

React guru, Kent C Dodds, enlightened me to the performance benefits of CSS variables over React context with his blog post [Use CSS Variables instead of React Context](https://epicreact.dev/css-variables/). Performance **always** matters, and with [95% browser coverage](https://caniuse.com/css-variables) it was an easy sell. In terms of how to put together colour swatches as part of a design system, inspiration came from Tailwind CSS, and implmentation from Elad Shechter with his article on [Why CSS HSL Colors are Better!](https://elad.medium.com/why-css-hsl-colors-are-better-83b1e0b6eead) The plan was in place.

## The Configuration

So how do we stitch all of this together for performant, well-organized theming coupled with the great DX of Emotion? We create a hybrid by following these steps:

1. Setup Emotion to work with the latest version of Next.js.
2. Take some design system elements from Tailwind and create a CSS Variable configuration.
3. Create a theme object based on the theme specification from Theme UI which consumes the CSS Variables.
4. Create a toggle component to switch between themes.

## Configuring Emotion with Next.js

Emotion 11 installation is as easy as `npm i @emotion/react @emotion/styled`. To avoid having to use a pragma atop every file that relies on the Emotion `css` prop, we also want to `npm i @emotion/babel-plugin`. For the plugin to work, and to use [the new JSX transform](https://reactjs.org/blog/2020/09/22/introducing-the-new-jsx-transform.html) in React 17 which ships with the latest verion of Next.js, we need to define a custom Babel config as follows in a `.babelrc` file in the root directory.

```shell
{
  "presets": [
    [
      "next/babel",
      {
        "preset-react": {
          "runtime": "automatic",
          "importSource": "@emotion/react"
        }
      }
    ]
  ],
  "plugins": ["@emotion/babel-plugin"]
}
```

## Defining CSS Variables for the Theme

We define our colour scales Tailwind-style using CSS variables.

```css
/* styles/colors.css */
:root {
  --gray: 343, 6%;
  --gray-50: var(--gray), 95%;
  --gray-100: var(--gray), 90%;
  --gray-200: var(--gray), 80%;
  --gray-300: var(--gray), 70%;
  --gray-400: var(--gray), 60%;
  --gray-500: var(--gray), 50%;
  --gray-600: var(--gray), 40%;
  --gray-700: var(--gray), 30%;
  --gray-800: var(--gray), 20%;
  --gray-900: var(--gray), 10%;

  /* ...add other color swatches as desired */
}

body[data-theme='light'] {
  --colors-text: hsla(var(--gray-800), 100%);
  --colors-background: hsla(var(--yellow-50), 100%);
  --colors-primary: hsla(var(--orange-500), 100%);
  --colors-secondary: hsla(var(--orange-300), 100%);
  --colors-accent: hsla(var(--olive-600), 100%);
  --colors-highlight: hsla(var(--teal-200), 100%);
  --colors-muted: hsla(var(--yellow-200), 100%);
}

body[data-theme='dark'] {
  --colors-text: hsla(var(--yellow-50), 100%);
  --colors-background: hsla(var(--gray-800), 100%);
  --colors-primary: hsla(var(--orange-500), 100%);
  --colors-secondary: hsla(var(--orange-300), 100%);
  --colors-accent: hsla(var(--olive-600), 100%);
  --colors-highlight: hsla(var(--teal-200), 100%);
  --colors-muted: hsla(var(--yellow-200), 100%);
}
```

## Creating & Using a Theme with Emotion

Then we follow [Theme UI's theme specification](https://dev.theme-ui.com/theme-spec/) to build a thoughtfully structured theme, using our CSS variables for the `colors` object.

```ts
const baseColors = {
  transparent: 'transparent',
  black: '#000',
  white: '#fff',
  gray: [
    'var(--gray-50)',
    'var(--gray-100)',
    'var(--gray-200)',
    'var(--gray-300)',
    'var(--gray-400)',
    'var(--gray-500)',
    'var(--gray-600)',
    'var(--gray-700)',
    'var(--gray-800)',
    'var(--gray-900)',
  ],
  // other color swatches from colors.css
};

const defaultColors = {
  text: 'var(--colors-text)',
  background: 'var(--colors-background)',
  primary: 'var(--colors-primary)',
  secondary: 'var(--colors-secondary)',
  accent: 'var(--colors-accent)',
  highlight: 'var(--colors-highlight)',
  muted: 'var(--colors-muted)',
};

export const colors = {
  ...baseColors,
  ...defaultColors,
};
```

Next we use Emotion's `<Global/>` component to apply the theme colors.

```tsx
// _app.tsx
import type { AppProps } from 'next/app';
import { Global } from '@emotion/react';
import theme from 'theme';
import 'styles/colors.css';

function App({ Component, pageProps }: AppProps) {
  return (
    <>
      <Global
        styles={{
          body: {
            background: theme.colors.background,
            color: theme.colors.text,
          },

          a: {
            color: theme.colors.primary,
          },
        }}
      />
      <Component {...pageProps} />
    </>
  );
}

export default App;
```

## Building a Theme Toggle Component

And lastly we create a theme toggle to switch between themes using CSS [data attributes](https://developer.mozilla.org/en-US/docs/Learn/HTML/Howto/Use_data_attributes).

```tsx
// ModeToggle.tsx
import * as React from 'react';
import { FiSun, FiMoon } from 'react-icons/fi';
import { StyledButton } from './styled';
import { useLocalStorageState } from 'hooks';

export function ModeToggle() {
  const [theme, setTheme] = React.useState('light');
  const nextTheme = theme === 'light' ? 'dark' : 'light';

  React.useEffect(() => {
    document.body.dataset.theme = theme;
  }, [theme]);

  return (
    <StyledButton
      aria-label="Toggle colour mode"
      onClick={() => setTheme(nextTheme)}
    >
      {nextTheme === 'light' ? <FiMoon /> : <FiSun />}
    </StyledButton>
  );
}
```

## Just One More Thing...

But there is one more matter to consider. Next.js re-renders on route changes and therefore our theme state will be lost when we navigate to a different page. We need to persist state, for which we will use `localStorage`.

## Persisting Between Route Changes

One of the many elegant patterns I learned from Kent C Dodd's [Epic React](https://epicreact.dev/) course is to create a generic custom hook for storing state in `localStorage`. To avoid an error being thrown, we also need to ensure not to try and access `window` on the server where it will be `undefined` as per the [Next.js docs](https://nextjs.org/docs/migrating/from-create-react-app#safely-accessing-web-apis).

```tsx
// use-local-storage-state.tsx
import * as React from 'react';

export function useLocalStorageState(
  key: string,
  defaultValue: string | (() => void),
  { serialize = JSON.stringify, deserialize = JSON.parse } = {},
) {
  const [state, setState] = React.useState(() => {
    // do not try to run this on the server!
    if (typeof window === 'undefined') return;
    const valueInLocalStorage = window.localStorage.getItem(key);

    if (valueInLocalStorage) {
      // the try/catch is here in case the localStorage value was set before we had the serialization in place
      try {
        return deserialize(valueInLocalStorage);
      } catch (error) {
        window.localStorage.removeItem(key);
      }
    }
    return typeof defaultValue === 'function' ? defaultValue() : defaultValue;
  });

  const prevKeyRef = React.useRef(key);

  React.useEffect(() => {
    const prevKey = prevKeyRef.current;
    if (prevKey !== key) {
      window.localStorage.removeItem(prevKey);
    }
    prevKeyRef.current = key;
    window.localStorage.setItem(key, serialize(state));
  }, [key, state, serialize]);

  return [state, setState];
}
```

Now we can replace the call to `React.useState()` with `useLocalStorageState()` in our `ModeToggle` component.

```tsx
import { FiSun, FiMoon } from 'react-icons/fi';
import { StyledButton } from './styled';
import { useLocalStorageState } from 'hooks';

export function ModeToggle() {
  const [theme, setTheme] = useLocalStorageState('theme', 'light');
  const nextTheme = theme === 'light' ? 'dark' : 'light';

  React.useEffect(() => {
    document.body.dataset.theme = theme;
  }, [theme]);

  return (
    <StyledButton
      aria-label="Toggle colour mode"
      onClick={() => setTheme(nextTheme)}
    >
      {nextTheme === 'light' ? <FiMoon /> : <FiSun />}
    </StyledButton>
  );
}
```

## Summary

To recap, we have created a Next.js configuration with great DX featuring:

- Emotion for [all of the benefits](https://mxstbr.com/thoughts/css-in-js/) that CSS-in-JS brings configured to work with the latest version of Next.js.
- Perforamant theming through the use of CSS Custom Properties (variables).
- An organized theme structure based on the theme specification used by Theme UI.
- An elegant reusable hook for storing anything we wish in the browser's local storage.

The big takeaway I have learned from all this is to use a suitable approach for the task at hand, and not create complexity where it isn't justifiable. Sometimes we can get carried away with creating solutions for problems that can be observed in other ways, which only becomes apparent when we step away from the code and look at the bigger picture.
